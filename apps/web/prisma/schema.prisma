generator client {
  provider        = "prisma-client-js"
  output          = "../../../node_modules/.prisma/client"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native", "rhel-openssl-1.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model Account {
  id                String        @id @default(cuid())
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailAccount      EmailAccount?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                       String         @id @default(cuid())
  createdAt                DateTime       @default(now())
  updatedAt                DateTime       @updatedAt
  name                     String?
  email                    String         @unique
  emailVerified            DateTime?
  image                    String?
  aiModel                  String?
  aiApiKey                 String?
  premiumId                String?
  onboardingAnswers        Json?
  aiProvider               String?
  lastLogin                DateTime?
  utms                     Json?
  premiumAdminId           String?
  errorMessages            Json?
  completedAppOnboardingAt DateTime?
  completedOnboardingAt    DateTime?
  webhookSecret            String?
  accounts                 Account[]
  apiKeys                  ApiKey[]
  emailAccounts            EmailAccount[]
  sessions                 Session[]
  premiumAdmin             Premium?       @relation(fields: [premiumAdminId], references: [id])
  premium                  Premium?       @relation("userPremium", fields: [premiumId], references: [id])
}

model EmailAccount {
  createdAt                 DateTime          @default(now())
  updatedAt                 DateTime          @updatedAt
  email                     String            @unique
  writingStyle              String?
  userId                    String
  accountId                 String            @unique
  about                     String?
  autoCategorizeSenders     Boolean           @default(false)
  behaviorProfile           Json?
  coldEmailBlocker          ColdEmailSetting?
  coldEmailPrompt           String?
  lastSummaryEmailAt        DateTime?
  lastSyncedHistoryId       String?
  outboundReplyTracking     Boolean           @default(false)
  rulesPrompt               String?
  signature                 String?
  statsEmailFrequency       Frequency         @default(WEEKLY)
  summaryEmailFrequency     Frequency         @default(WEEKLY)
  watchEmailsExpirationDate DateTime?
  id                        String            @id @default(cuid())
  image                     String?
  name                      String?
  categories                Category[]
  chats                     Chat[]
  cleanupJobs               CleanupJob[]
  cleanupThreads            CleanupThread[]
  coldEmails                ColdEmail[]
  account                   Account           @relation(fields: [accountId], references: [id], onDelete: Cascade)
  user                      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailMessages             EmailMessage[]
  emailTokens               EmailToken[]
  executedRules             ExecutedRule[]
  groups                    Group[]
  knowledge                 Knowledge[]
  labels                    Label[]
  newsletters               Newsletter[]
  rules                     Rule[]
  threadTrackers            ThreadTracker[]

  @@index([lastSummaryEmailAt])
}

model Premium {
  id                             String       @id @default(cuid())
  createdAt                      DateTime     @default(now())
  updatedAt                      DateTime     @updatedAt
  lemonSqueezyRenewsAt           DateTime?
  lemonSqueezyCustomerId         Int?
  lemonSqueezySubscriptionId     Int?
  lemonSqueezySubscriptionItemId Int?
  lemonSqueezyOrderId            Int?
  lemonSqueezyProductId          Int?
  lemonSqueezyVariantId          Int?
  tier                           PremiumTier?
  emailAccountsAccess            Int?
  unsubscribeMonth               Int?
  unsubscribeCredits             Int?
  aiMonth                        Int?
  aiCredits                      Int?
  lemonLicenseInstanceId         String?
  lemonLicenseKey                String?
  pendingInvites                 String[]
  lemonSubscriptionStatus        String?
  stripeCancelAtPeriodEnd        Boolean?
  stripeCanceledAt               DateTime?
  stripeCustomerId               String?      @unique
  stripeEndedAt                  DateTime?
  stripePriceId                  String?
  stripeProductId                String?
  stripeRenewsAt                 DateTime?
  stripeSubscriptionId           String?      @unique
  stripeSubscriptionItemId       String?      @unique
  stripeSubscriptionStatus       String?
  stripeTrialEnd                 DateTime?
  payments                       Payment[]
  admins                         User[]
  users                          User[]       @relation("userPremium")

  @@index([pendingInvites])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Label {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  gmailLabelId   String
  name           String
  description    String?
  enabled        Boolean      @default(true)
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([gmailLabelId, emailAccountId])
  @@unique([name, emailAccountId])
}

model Rule {
  id                  String              @id @default(cuid())
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  instructions        String?
  automate            Boolean             @default(false)
  name                String
  runOnThreads        Boolean             @default(false)
  body                String?
  from                String?
  groupId             String?             @unique
  subject             String?
  to                  String?
  enabled             Boolean             @default(true)
  categoryFilterType  CategoryFilterType?
  conditionalOperator LogicalOperator     @default(AND)
  systemType          SystemType?
  emailAccountId      String
  actions             Action[]
  executedRules       ExecutedRule[]
  emailAccount        EmailAccount        @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  group               Group?              @relation(fields: [groupId], references: [id], onDelete: Cascade)
  categoryFilters     Category[]          @relation("CategoryToRule")

  @@unique([name, emailAccountId])
  @@unique([emailAccountId, systemType])
}

model Action {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  type      ActionType
  ruleId    String
  label     String?
  subject   String?
  content   String?
  to        String?
  cc        String?
  bcc       String?
  url       String?
  rule      Rule       @relation(fields: [ruleId], references: [id], onDelete: Cascade)
}

model ExecutedRule {
  id             String             @id @default(cuid())
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  threadId       String
  messageId      String
  automated      Boolean
  ruleId         String?
  reason         String?
  status         ExecutedRuleStatus
  emailAccountId String
  actionItems    ExecutedAction[]
  emailAccount   EmailAccount       @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  rule           Rule?              @relation(fields: [ruleId], references: [id])

  @@unique([emailAccountId, threadId, messageId], name: "unique_emailAccount_thread_message")
  @@index([emailAccountId, status, createdAt])
}

model ExecutedAction {
  id             String        @id @default(cuid())
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  type           ActionType
  executedRuleId String
  label          String?
  subject        String?
  content        String?
  to             String?
  cc             String?
  bcc            String?
  url            String?
  draftId        String?
  wasDraftSent   Boolean?
  draftSendLog   DraftSendLog?
  executedRule   ExecutedRule  @relation(fields: [executedRuleId], references: [id], onDelete: Cascade)
}

model Group {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  name           String
  prompt         String?
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  items          GroupItem[]
  rule           Rule?

  @@unique([name, emailAccountId])
}

model GroupItem {
  id        String        @id @default(cuid())
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  groupId   String?
  type      GroupItemType
  value     String
  exclude   Boolean       @default(false)
  group     Group?        @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([groupId, type, value])
}

model Category {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  name           String
  description    String?
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  emailSenders   Newsletter[]
  rules          Rule[]       @relation("CategoryToRule")

  @@unique([name, emailAccountId])
}

model Newsletter {
  id              String            @id @default(cuid())
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  email           String
  status          NewsletterStatus?
  categoryId      String?
  lastAnalyzedAt  DateTime?
  patternAnalyzed Boolean           @default(false)
  emailAccountId  String
  category        Category?         @relation(fields: [categoryId], references: [id])
  emailAccount    EmailAccount      @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([email, emailAccountId])
  @@index([emailAccountId, status])
}

model ColdEmail {
  id             String           @id @default(cuid())
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  fromEmail      String
  messageId      String?
  threadId       String?
  status         ColdEmailStatus?
  reason         String?
  emailAccountId String
  emailAccount   EmailAccount     @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([emailAccountId, fromEmail])
  @@index([emailAccountId, status])
  @@index([emailAccountId, createdAt])
}

model EmailMessage {
  id              String       @id @default(cuid())
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  threadId        String
  messageId       String
  date            DateTime
  from            String
  fromDomain      String
  to              String
  unsubscribeLink String?
  read            Boolean
  sent            Boolean
  draft           Boolean
  inbox           Boolean
  emailAccountId  String
  emailAccount    EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([emailAccountId, threadId, messageId])
  @@index([emailAccountId, threadId])
  @@index([emailAccountId, date])
  @@index([emailAccountId, from])
}

model ThreadTracker {
  id             String            @id @default(cuid())
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  threadId       String
  messageId      String
  resolved       Boolean           @default(false)
  type           ThreadTrackerType
  sentAt         DateTime
  emailAccountId String
  emailAccount   EmailAccount      @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([emailAccountId, threadId, messageId])
  @@index([emailAccountId, resolved])
  @@index([emailAccountId, resolved, sentAt, type])
  @@index([emailAccountId, type, resolved, sentAt])
}

model CleanupJob {
  id               String          @id @default(cuid())
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  action           CleanAction     @default(ARCHIVE)
  daysOld          Int             @default(7)
  instructions     String?
  skipAttachment   Boolean?
  skipCalendar     Boolean?
  skipReceipt      Boolean?
  skipReply        Boolean?
  skipStarred      Boolean?
  skipConversation Boolean?
  emailAccountId   String
  emailAccount     EmailAccount    @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  threads          CleanupThread[]
}

model CleanupThread {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  threadId       String
  archived       Boolean
  jobId          String
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  job            CleanupJob   @relation(fields: [jobId], references: [id], onDelete: Cascade)
}

model Knowledge {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  title          String
  content        String
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id])

  @@unique([emailAccountId, title])
}

model ApiKey {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  hashedKey String   @unique
  isActive  Boolean  @default(true)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
}

model EmailToken {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  token          String       @unique
  expiresAt      DateTime
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
}

model Payment {
  id                      String        @id @default(cuid())
  createdAt               DateTime
  updatedAt               DateTime
  premiumId               String?
  processorId             String?       @unique
  processorSubscriptionId String?
  processorCustomerId     String?
  amount                  Int
  currency                String
  status                  String
  refunded                Boolean       @default(false)
  refundedAt              DateTime?
  refundedAmount          Int?
  billingReason           String?
  processorType           ProcessorType @default(LEMON_SQUEEZY)
  tax                     Int
  taxInclusive            Boolean
  premium                 Premium?      @relation(fields: [premiumId], references: [id])
}

model DraftSendLog {
  id               String         @id @default(cuid())
  createdAt        DateTime       @default(now())
  executedActionId String         @unique
  sentMessageId    String
  similarityScore  Float
  executedAction   ExecutedAction @relation(fields: [executedActionId], references: [id], onDelete: Cascade)

  @@index([executedActionId])
}

model Chat {
  id             String        @id @default(cuid())
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  emailAccountId String
  emailAccount   EmailAccount  @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  messages       ChatMessage[]

  @@index([emailAccountId])
}

model ChatMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      String
  chatId    String
  parts     Json
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId])
}

enum ActionType {
  ARCHIVE
  LABEL
  REPLY
  SEND_EMAIL
  FORWARD
  DRAFT_EMAIL
  MARK_SPAM
  CALL_WEBHOOK
  MARK_READ
  TRACK_THREAD
}

enum Frequency {
  NEVER
  WEEKLY
}

enum NewsletterStatus {
  APPROVED
  UNSUBSCRIBED
  AUTO_ARCHIVED
}

enum ColdEmailStatus {
  AI_LABELED_COLD
  USER_REJECTED_COLD
}

enum ColdEmailSetting {
  DISABLED
  LIST
  LABEL
  ARCHIVE_AND_LABEL
  ARCHIVE_AND_READ_AND_LABEL
}

enum PremiumTier {
  PRO_MONTHLY
  PRO_ANNUALLY
  BUSINESS_MONTHLY
  BUSINESS_ANNUALLY
  LIFETIME
  BASIC_MONTHLY
  BASIC_ANNUALLY
  COPILOT_MONTHLY
  BUSINESS_PLUS_MONTHLY
  BUSINESS_PLUS_ANNUALLY
}

enum ExecutedRuleStatus {
  APPLIED
  REJECTED
  PENDING
  SKIPPED
  APPLYING
  ERROR
}

enum GroupItemType {
  FROM
  SUBJECT
  BODY
}

enum CategoryFilterType {
  INCLUDE
  EXCLUDE
}

enum LogicalOperator {
  AND
  OR
}

enum ThreadTrackerType {
  AWAITING
  NEEDS_REPLY
  NEEDS_ACTION
}

enum ProcessorType {
  LEMON_SQUEEZY
  STRIPE
}

enum CleanAction {
  ARCHIVE
  MARK_READ
}

enum SystemType {
  TO_REPLY
  NEWSLETTER
  MARKETING
  CALENDAR
  RECEIPT
  NOTIFICATION
}
